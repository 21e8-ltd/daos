From 7abe7db0c11c8ff4348c4ecbfb5c3c0bdc709161 Mon Sep 17 00:00:00 2001
From: Vishwanath Venkatesan <vishwanath.venkatesan@intel.com>
Date: Thu, 13 Jul 2017 01:24:00 +0200
Subject: [PATCH] ARM support for NVML libraries

This patch
-- Adds neon mneomonics for NVML to make it work on ARM (neon_sse.h)
	-- Add a new vairable AARCH64 to pick ARM build
	-- Currently cflushopt and clwb don't have any replacement.
-- Adding changes to Makefiles to skip building tools and examples

Signed-off-by: Vishwanath Venkatesan <vishwanath.venkatesan@intel.com>
---
 src/Makefile          | 10 ++++++++--
 src/common/neon_sse.h | 29 +++++++++++++++++++++++++++++
 src/examples/Makefile |  2 +-
 src/libpmem/cpu.c     |  5 +----
 src/libpmem/pmem.c    | 30 +++++++++++++++++++++++-------
 5 files changed, 62 insertions(+), 14 deletions(-)
 create mode 100644 src/common/neon_sse.h

diff --git a/src/Makefile b/src/Makefile
index 53f5c16a..8df8a4cb 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -37,8 +37,14 @@ include $(TOP)/src/common.inc
 include $(TOP)/src/version.inc
 
 TARGETS = libpmem libvmem libpmemblk libpmemlog libpmemobj libpmempool\
-	libvmmalloc tools
-ALL_TARGETS = $(TARGETS) common librpmem examples benchmarks
+	libvmmalloc
+
+ifneq ($(BUILD_AARCH64),y)
+	ALL_TARGETS = $(TARGETS) common librpmem examples benchmarks tools
+else
+	ALL_TARGETS = $(TARGETS) common
+endif
+
 SCOPE_DIRS = $(TARGETS) common librpmem rpmem_common
 
 DEBUG_RELEASE_TARGETS = common libpmem libvmem libpmemblk libpmemlog libpmemobj\
diff --git a/src/common/neon_sse.h b/src/common/neon_sse.h
new file mode 100644
index 00000000..48136812
--- /dev/null
+++ b/src/common/neon_sse.h
@@ -0,0 +1,29 @@
+#ifndef NEON_SSE_H
+#define NEON_SSE_H
+
+#include <stdlib.h>
+
+static __inline void
+_mm_clflush(void const *p __attribute__((unused)))
+{
+	asm volatile("dc cvac, %0" : : "r" (p) : "memory");
+}
+
+static __inline void
+_mm_sfence(void)
+{
+	asm volatile("dmb ish" : : : "memory");
+}
+
+static inline void
+_mm_clwb(const void *addr)
+{
+	asm volatile("dc cvac, %0" : : "r" (addr) : "memory");
+}
+
+static inline void
+_mm_clflushopt(char *uptr)
+{
+	asm volatile("dc civac, %0" : : "r" (uptr) : "memory");
+}
+#endif
diff --git a/src/examples/Makefile b/src/examples/Makefile
index 53455667..2b0f7900 100644
--- a/src/examples/Makefile
+++ b/src/examples/Makefile
@@ -35,7 +35,7 @@
 #
 
 DIRS = libpmem libpmemblk libpmemlog libpmemobj libvmem librpmem\
-	libpmempool
+       libpmempool
 
 include Makefile.inc
 
diff --git a/src/libpmem/cpu.c b/src/libpmem/cpu.c
index 3be87ff4..6731be42 100644
--- a/src/libpmem/cpu.c
+++ b/src/libpmem/cpu.c
@@ -80,10 +80,6 @@ cpuid(unsigned func, unsigned subfunc, unsigned cpuinfo[4])
 
 #endif
 
-#ifndef bit_SSE2
-#define bit_SSE2	(1 << 26)
-#endif
-
 #ifndef bit_CLFLUSH
 #define bit_CLFLUSH	(1 << 23)
 #endif
@@ -110,6 +106,7 @@ is_cpu_feature_present(unsigned func, unsigned reg, unsigned bit)
 		return 0;
 
 	cpuid(func, 0x0, cpuinfo);
+	printf("Result: %d\n", ((cpuinfo[reg] & bit) != 0));
 	return (cpuinfo[reg] & bit) != 0;
 }
 
diff --git a/src/libpmem/pmem.c b/src/libpmem/pmem.c
index a9339a6b..7e106f20 100644
--- a/src/libpmem/pmem.c
+++ b/src/libpmem/pmem.c
@@ -170,7 +170,9 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <string.h>
+#ifndef AARCH64
 #include <emmintrin.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -189,6 +191,9 @@
 #include "mmap.h"
 #include "file.h"
 #include "valgrind_internal.h"
+#ifdef AARCH64
+#include "neon_sse.h"
+#endif
 
 #ifndef _MSC_VER
 /*
@@ -196,15 +201,18 @@
  * intrinsic functions are not always available.  The intrinsic
  * functions are defined here in terms of asm statements for now.
  */
+
+#ifndef AARCH64
 #define _mm_clflushopt(addr)\
 	asm volatile(".byte 0x66; clflush %0" : "+m" (*(volatile char *)addr));
 #define _mm_clwb(addr)\
 	asm volatile(".byte 0x66; xsaveopt %0" : "+m" (*(volatile char *)addr));
-
+#endif /* AARCH64 */
 #endif /* _MSC_VER */
 
 #define FLUSH_ALIGN ((uintptr_t)64)
 
+#ifndef AARCH64
 #define ALIGN_MASK	(FLUSH_ALIGN - 1)
 
 #define CHUNK_SIZE	128 /* 16*8 */
@@ -222,6 +230,7 @@
 #define MOVNT_THRESHOLD	256
 
 static size_t Movnt_threshold = MOVNT_THRESHOLD;
+#endif
 
 /*
  * pmem_has_hw_drain -- return whether or not HW drain was found
@@ -297,8 +306,9 @@ flush_clflush(const void *addr, size_t len)
 	 * covering the given range.
 	 */
 	for (uptr = (uintptr_t)addr & ~(FLUSH_ALIGN - 1);
-		uptr < (uintptr_t)addr + len; uptr += FLUSH_ALIGN)
+		uptr < (uintptr_t)addr + len; uptr += FLUSH_ALIGN) {
 		_mm_clflush((char *)uptr);
+	}
 }
 
 /*
@@ -770,6 +780,7 @@ memmove_nodrain_normal(void *pmemdest, const void *src, size_t len)
 	return pmemdest;
 }
 
+#ifndef AARCH64
 /*
  * memmove_nodrain_movnt -- (internal) memmove to pmem without hw drain, movnt
  */
@@ -777,7 +788,6 @@ static void *
 memmove_nodrain_movnt(void *pmemdest, const void *src, size_t len)
 {
 	LOG(15, "pmemdest %p src %p len %zu", pmemdest, src, len);
-
 	__m128i xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7;
 	size_t i;
 	__m128i *d;
@@ -986,6 +996,7 @@ memmove_nodrain_movnt(void *pmemdest, const void *src, size_t len)
 
 	return pmemdest;
 }
+#endif
 
 /*
  * pmem_memmove_nodrain() calls through Func_memmove_nodrain to do the work.
@@ -1061,6 +1072,7 @@ memset_nodrain_normal(void *pmemdest, int c, size_t len)
 /*
  * memset_nodrain_movnt -- (internal) memset to pmem without hw drain, movnt
  */
+#ifndef AARCH64
 static void *
 memset_nodrain_movnt(void *pmemdest, int c, size_t len)
 {
@@ -1148,6 +1160,7 @@ memset_nodrain_movnt(void *pmemdest, int c, size_t len)
 
 	return pmemdest;
 }
+#endif
 
 /*
  * pmem_memset_nodrain() calls through Func_memset_nodrain to do the work.
@@ -1203,10 +1216,12 @@ pmem_log_cpuinfo(void)
 	else
 		FATAL("invalid flush function address");
 
-	if (Func_memmove_nodrain == memmove_nodrain_movnt)
-		LOG(3, "using movnt");
-	else if (Func_memmove_nodrain == memmove_nodrain_normal)
+	if (Func_memmove_nodrain == memmove_nodrain_normal)
 		LOG(3, "not using movnt");
+#ifndef AARCH64
+	else if (Func_memmove_nodrain == memmove_nodrain_movnt)
+		LOG(3, "using movnt");
+#endif
 	else
 		FATAL("invalid memove_nodrain function address");
 }
@@ -1266,6 +1281,7 @@ pmem_init(void)
 		Func_predrain_fence = predrain_fence_sfence;
 	}
 
+#ifndef AARCH64
 	/*
 	 * For testing, allow overriding the default threshold
 	 * for using non-temporal stores in pmem_memcpy_*(), pmem_memmove_*()
@@ -1291,7 +1307,7 @@ pmem_init(void)
 		Func_memmove_nodrain = memmove_nodrain_movnt;
 		Func_memset_nodrain = memset_nodrain_movnt;
 	}
-
+#endif
 	pmem_log_cpuinfo();
 
 #if defined(_WIN32) && (NTDDI_VERSION >= NTDDI_WIN10_RS1)
-- 
2.12.3

