From 97875a9c82becb72a35c0c5b33bb1992814eb871 Mon Sep 17 00:00:00 2001
From: Xuezhao Liu <xuezhao.liu@intel.com>
Date: Tue, 12 Apr 2016 23:56:22 +0800
Subject: [PATCH 1/2] change port number for tcp and verbs transport

When user calls cci_create_endpoint it will increase the port number
in the CCI_CONFIG file by one, then user can get the continue listening
addresses.

This patch make the change for tcp and verbs transport.

Signed-off-by: Xuezhao Liu <xuezhao.liu@intel.com>
---
 src/plugins/ctp/tcp/ctp_tcp_api.c     | 16 ++++++++++++++--
 src/plugins/ctp/verbs/ctp_verbs_api.c | 17 ++++++++++++++++-
 2 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/src/plugins/ctp/tcp/ctp_tcp_api.c b/src/plugins/ctp/tcp/ctp_tcp_api.c
index 6e66f2f..c69082e 100644
--- a/src/plugins/ctp/tcp/ctp_tcp_api.c
+++ b/src/plugins/ctp/tcp/ctp_tcp_api.c
@@ -615,8 +615,20 @@ static int ctp_tcp_create_endpoint(cci_device_t * device,
 	memset(&sin, 0, sizeof(sin));
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = tdev->ip;
-	if (tdev->port != 0)
-        sin.sin_port = tdev->port;
+	if (tdev->port != 0) {
+		static pthread_mutex_t tcp_port_mutex =
+			PTHREAD_MUTEX_INITIALIZER;
+		static short s_tcp_port = 0;
+
+		pthread_mutex_lock(&tcp_port_mutex);
+		if (s_tcp_port == 0) {
+			s_tcp_port = ntohs(tdev->port);
+		} else {
+			s_tcp_port++;
+		}
+		sin.sin_port = htons(s_tcp_port);
+		pthread_mutex_unlock(&tcp_port_mutex);
+	}
 
 	ret = bind(sock, (const struct sockaddr *)&sin, sizeof(sin));
 	if (ret) {
diff --git a/src/plugins/ctp/verbs/ctp_verbs_api.c b/src/plugins/ctp/verbs/ctp_verbs_api.c
index 64c4f25..80811e5 100644
--- a/src/plugins/ctp/verbs/ctp_verbs_api.c
+++ b/src/plugins/ctp/verbs/ctp_verbs_api.c
@@ -1170,14 +1170,29 @@ ctp_verbs_create_endpoint(cci_device_t * device,
 		ret = errno;
 		goto out;
 	}
-
 	vep->sin = *((struct sockaddr_in *)vdev->ifa->ifa_addr);
 
+	if (vep->sin.sin_port != 0) {
+		static pthread_mutex_t verb_port_mutex =
+			PTHREAD_MUTEX_INITIALIZER;
+		static short s_verb_port = 0;
+
+		pthread_mutex_lock(&verb_port_mutex);
+		if (s_verb_port == 0) {
+			s_verb_port = ntohs(vep->sin.sin_port);
+		} else {
+			s_verb_port++;
+		}
+		vep->sin.sin_port = htons(s_verb_port);
+		pthread_mutex_unlock(&verb_port_mutex);
+	}
+
 	ret = rdma_bind_addr(vep->id_rc, (struct sockaddr *)&vep->sin);
 	if (ret == -1) {
 		ret = errno;
 		goto out;
 	}
+
 	vep->sin.sin_port = rdma_get_src_port(vep->id_rc);
 
 	ret = rdma_listen(vep->id_rc, 1024);
-- 
1.8.3.1

